<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ZEN University â€“ Minimal Generative Art</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas { display: block; }
  </style>
  <!-- Include p5.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
</head>
<body>
  <script>
    /*
     * Lightweight generative art for "ZEN University" that transitions through
     * three text scenes and ends with a gentle collapse effect. There are no
     * background particles to keep the scene clean and efficient. The timing
     * of transitions can be adjusted via the stage duration constants.
     */

    let zenPoints = [];
    let rmPoints  = [];
    let enterPoints = [];
    let particles = [];
    let fragments = [];

    let stage = 0;           // 0: ZEN, 1: rm, 2: ENTER, 3: collapse
    let stageStartTime = 0;
    let inverted = false;
    let snapshotTaken = false;
    const fragSize = 50;     // Larger fragment size for lighter collapse

    // Duration for each stage in milliseconds
    const DURATION_ZEN   = 3000;
    const DURATION_RM    = 3000; // 1 second longer than before
    const DURATION_ENTER = 1000;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 100);
      noStroke();
      stageStartTime = millis();

      // Generate point arrays for each text
      zenPoints   = getPointsForText("ZEN University");
      rmPoints    = getPointsForText("sudo rm -rf /");
      enterPoints = getPointsForText("ENTER");

      // Determine maximum number of points across texts
      const maxPoints = max(zenPoints.length, rmPoints.length, enterPoints.length);

      // Create particles
      for (let i = 0; i < maxPoints; i++) {
        particles.push(new Particle(random(width), random(height)));
      }

      // Assign initial targets for ZEN stage
      assignTargets(zenPoints);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      stage = 0;
      inverted = false;
      snapshotTaken = false;
      fragments = [];
      stageStartTime = millis();
      // Regenerate points and resize particle array as needed
      zenPoints   = getPointsForText("ZEN University");
      rmPoints    = getPointsForText("sudo rm -rf /");
      enterPoints = getPointsForText("ENTER");
      const maxPoints = max(zenPoints.length, rmPoints.length, enterPoints.length);
      if (particles.length < maxPoints) {
        for (let i = particles.length; i < maxPoints; i++) {
          particles.push(new Particle(random(width), random(height)));
        }
      }
      assignTargets(zenPoints);
    }

    function draw() {
      // Semi-transparent background for trailing effect
      if (inverted) {
        background(0, 0, 100, 10); // white
      } else {
        background(0, 0, 0, 10); // black
      }

      // Stage timing logic
      const elapsed = millis() - stageStartTime;
      if (stage === 0 && elapsed > DURATION_ZEN) {
        stage = 1;
        stageStartTime = millis();
        assignTargets(rmPoints);
      } else if (stage === 1 && elapsed > DURATION_RM) {
        stage = 2;
        stageStartTime = millis();
        inverted = !inverted;
        assignTargets(enterPoints);
      } else if (stage === 2 && elapsed > DURATION_ENTER) {
        stage = 3;
        stageStartTime = millis();
      }

      // Render according to stage
      if (stage < 3) {
        for (let p of particles) {
          p.update();
          p.show();
        }
      }
      if (stage === 3) {
        if (!snapshotTaken) {
          snapshotTaken = true;
          captureFragments();
        }
        for (let frag of fragments) {
          frag.update();
          frag.show();
        }
      }
    }

    // Create point array for a given text by sampling an offscreen buffer
    function getPointsForText(str) {
      const pg = createGraphics(width, height);
      pg.pixelDensity(1);
      pg.background(0);
      pg.fill(255);
      pg.textAlign(CENTER, CENTER);
      const fontSize = min(width, height) * 0.12;
      pg.textSize(fontSize);
      pg.text(str, width / 2, height / 2);
      pg.loadPixels();
      const pts = [];
      const step = 6;
      const threshold = 128;
      for (let x = 0; x < pg.width; x += step) {
        for (let y = 0; y < pg.height; y += step) {
          const idx = 4 * (x + y * pg.width);
          const r = pg.pixels[idx];
          if (r > threshold) pts.push(createVector(x, y));
        }
      }
      return pts;
    }

    // Assign target positions to particles
    function assignTargets(targetArray) {
      const count = targetArray.length;
      for (let i = 0; i < particles.length; i++) {
        if (i < count) {
          particles[i].setTarget(targetArray[i]);
        } else {
          particles[i].setTarget(createVector(random(width), height + 200));
        }
      }
    }

    // Capture current frame and create fragments
    function captureFragments() {
      const snap = get();
      fragments = [];
      for (let x = 0; x < width; x += fragSize) {
        for (let y = 0; y < height; y += fragSize) {
          const tile = snap.get(x, y, fragSize, fragSize);
          fragments.push(new Fragment(tile, x + fragSize / 2, y + fragSize / 2));
        }
      }
    }

    // Particle class
    class Particle {
      constructor(x, y) {
        this.position = createVector(x, y);
        this.velocity = p5.Vector.random2D().mult(4);
        this.acceleration = createVector();
        this.target = this.position.copy();
        this.maxSpeed = random(8, 14);
        this.maxForce = random(1.5, 3);
        this.hue = random(0, 360);
        this.size = random(2, 5);
      }
      setTarget(vec) {
        this.target = vec.copy();
      }
      update() {
        const desired = p5.Vector.sub(this.target, this.position);
        const d = desired.mag();
        let speed = this.maxSpeed;
        if (d < 100) speed = map(d, 0, 100, 0, this.maxSpeed);
        if (d < 1) desired.setMag(0); else desired.setMag(speed);
        const steer = p5.Vector.sub(desired, this.velocity);
        steer.limit(this.maxForce);
        this.acceleration.add(steer);
        this.velocity.add(this.acceleration);
        this.velocity.mult(0.90);
        this.position.add(this.velocity);
        this.acceleration.mult(0);
      }
      show() {
        // Colour adjustment based on inversion
        let h = this.hue;
        let b = 100;
        if (inverted) {
          h = (h + 180) % 360;
          b = 0;
        }
        fill(h, 80, b + 50);
        ellipse(this.position.x, this.position.y, this.size);
      }
    }

    // Fragment class for collapse effect
    class Fragment {
      constructor(img, x, y) {
        this.img = img;
        this.pos = createVector(x, y);
        // Random velocities for falling effect
        this.vel = createVector(random(-2, 2), random(3, 6));
        this.alpha = 255;
      }
      update() {
        this.pos.add(this.vel);
        this.vel.y += 0.4; // mild gravity
        this.alpha -= 2;   // fade out
      }
      show() {
        push();
        translate(this.pos.x, this.pos.y);
        // Draw with current alpha
        tint(255, this.alpha);
        image(this.img, -fragSize / 2, -fragSize / 2, fragSize, fragSize);
        pop();
      }
    }
  </script>
</body>
</html>
